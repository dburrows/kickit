#!/usr/bin/env node
var debug = require('debug')('kickit');
var program = require('commander');
var Promise = require('bluebird');
var fs = require('fs');
var findup = require('findup-sync');
var chalk = require('chalk');
var exec = Promise.promisify(require('child_process').exec);
var spawn = require('child_process').spawn;
var path = require('path');


var version = require('../package.json').version;

var available_colors = [
  'green',
  'yellow',
  'blue',
  'magenta',
  'cyan',
  'gray'
];

program
  .version(version)
  .option('-c, --config <path>', 'config file path')
  .option('-e, --env <path>', 'environment file path')
  .parse(process.argv);

debug('config file: %s', program.config);
debug('env file: %s', program.env);

var childProcesses = require( validateConfigFile(program.config) );
var envFilePath = validateEnvFile(program.env);

var completed = [];

setEnv(envFilePath)
.then(spawnProcesses(childProcesses))
.then(pipeStdIn)
.catch(function( err ) {
  console.log('something wrong:', err);
});

function validateConfigFile(configPath) {
  var fp = configPath ? path.resolve(configPath) : findup('entry.json');
  if (fp && fs.existsSync(fp)) {
    return fp;
  } else {
    terminateProgram('Unable to find config file\n');
  }
}

function validateEnvFile(envFilePath) {
  var fp = envFilePath ? path.resolve(envFilePath) : undefined;
  if (fp && !fs.existsSync(fp)) {
    terminateProgram('Unable to find env file\n');
  } else {
    return fp;
  }
}

function setEnv(envFilePath) {
  if (!envFilePath) {
    return Promise.resolve();
  } else {
    return exec('source ' + envFilePath + ' && printenv', { cwd: envFilePath.replace(/\/.*/, '') })
    .then( function(stdout, stderr) {
      stdout.split('\n').forEach(function( line ) {
        var parts = line.split('=');
        process.env[ parts[0] ] = parts[1];
      });
      return;
    });
  }
}


function spawnProcesses(childProcesses) {
  // generic stdout & stderr
  childProcesses.forEach(function( cp, i ) {
    if (!cp.hasOwnProperty('waitOn')) {
      spawnProcess(cp, i);
    }
  });
}


function pipeStdIn() {
  process.stdin.resume();
  process.stdin.on('data', function( chunk ) {
    var s = chunk.toString('utf8');
    var cp = childProcesses.filter(function( cp ) {
      return typeof cp.stdinPrefix === 'string' && ( new RegExp('^' + cp.stdinPrefix + '\\.') ).test(s);
    })[ 0 ];
   
    if ( !cp ) {
      return console.log(('No target for input').red);
    }
   
    var cmd = s.substring(cp.stdinPrefix.length + 1);
    cp.process.stdin.write(cmd);
  });
}

function spawnProcess(cp, i) {
  // check to see if the bin exists
  commandExists(cp)
  .then(function() {
    cp.process = spawn(cp.spawn.command, cp.spawn.args);
    [ 'stdout', 'stderr' ].forEach(function( str ) {
      cp.process[ str ].on('data', function( data ) {
        process[ str ].write( 
          data.toString('utf8')
          .replace(/(^|\n)([^\n]+)/g, function( match, group1, group2 ) {
            return chalk[available_colors[i % available_colors.length]](group1 + ( cp.handle + ': ' ) + group2);
          })
        );
      })
      .on('error', function(err) {
        process.stdout.write( chalk[available_colors[i % available_colors.length]]( cp.handle + ': error\n' + err) );
      })
      .on('close', function ( code, signal ) {
        if (completed.indexOf(cp.handle) < 0) {
          completed.push(cp.handle);
          process.stdout.write(
            chalk[available_colors[i % available_colors.length]]( cp.handle + ': completed\n' )
          );
          childProcesses.forEach(function( cp2, i2 ) {
            if (cp2.hasOwnProperty('waitOn') && cp2.waitOn === cp.handle) {
              spawnProcess(cp2, i2);
            }
          });
          if (completed.length === childProcesses.length) {
            process.exit();
          }
        }
      });
    });
  })
  .catch(function(e) {
    console.log(chalk.red("Command %s failed to start:"),chalk.bold(cp.spawn.command)); 
    console.log(e.stack);
  });
}

function commandExists(cp) {
  return exec('command -v ' + cp.spawn.command + ' >/dev/null 2>&1 || { echo >&2; exit 1; }');
}

function terminateProgram(msg) {
  console.log(chalk.red(msg));
  process.exit(99);
}
