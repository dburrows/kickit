#!/usr/bin/env node
var extend = require('extend');
var debug = require('debug')('kickit');
var program = require('commander');
var Promise = require('bluebird');
var fs = require('fs');
var findup = require('findup-sync');
var chalk = require('chalk');
var exec = Promise.promisify(require('child_process').exec);
var spawn = require('child_process').spawn;
var path = require('path');

var version = require('../package.json').version;
var completedProcesses = [];
var available_colors = [
  'green',
  'yellow',
  'blue',
  'magenta',
  'cyan',
  'gray'
];

program
  .version(version)
  .option('-c, --config <path>', 'config file path')
  .option('-e, --env <path>', 'environment file path')
  .parse(process.argv);

debug('config file: %s', program.config);
debug('env file: %s', program.env);

// main

var childProcesses = require( validateConfigFile(program.config) );
var envFilePath = validateEnvFile(program.env);

setEnv(envFilePath)
.then(spawnProcesses(childProcesses))
.then(pipeStdIn)
.catch(function( err ) {
  console.log('Error:', err);
});

// clean up any running processes on exit

function exitHandler(options, err) {
  childProcesses.forEach(function(cp){
    if(cp.process && !cp.process.exitCode) {
      cp.process.kill();  
    }
  });
  if (err) console.log(err.stack);
  if (options.exit) process.exit();
}

//do something when app is closing
process.on('exit', exitHandler.bind(null,{}));

//catches ctrl+c event
process.on('SIGINT', exitHandler.bind(null, {exit:true}));

//catches uncaught exceptions
process.on('uncaughtException', exitHandler.bind(null, {exit:true}));


// functions

function validateConfigFile(configPath) {
  var fp = configPath ? path.resolve(configPath) : findup('kickfile.json');
  if (fp && fs.existsSync(fp)) {
    return fp;
  } else {
    terminateProgram('Unable to find config file\n');
  }
  // TODO: check handles are unique, exit if not 
}

function validateEnvFile(envFilePath) {
  var fp = envFilePath ? path.resolve(envFilePath) : undefined;
  if (fp && !fs.existsSync(fp)) {
    terminateProgram('Unable to find env file\n');
  } else {
    return fp;
  }
  // TODO: check envars are unique, warn if not
}

function setEnv(envFilePath) {
  if (!envFilePath) {
    return Promise.resolve();
  } else {
    return exec('source ' + envFilePath + ' && printenv', { cwd: envFilePath.replace(/\/.*/, '') })
    .then( function(output) {
      output[0].split('\n').forEach(function( line ) {
        var parts = line.split('=');
        process.env[ parts[0] ] = parts[1];
      });
      return;
    });
  }
}


function spawnProcesses(childProcesses) {
  // generic stdout & stderr
  childProcesses.forEach(function( cp, i ) {
    if (!cp.hasOwnProperty('waitOn')) {
      spawnProcess(cp, i);
    }
  });
}


function pipeStdIn() {

  process.stdin.on('data', function( chunk ) {
    var s = chunk.toString('utf8');
    var cp = childProcesses.filter(function( cp ) {
      return typeof cp.handle === 'string' && ( new RegExp('^' + cp.handle + '\\.') ).test(s);
    })[ 0 ];
    if ( !cp ) {
      return console.log(chalk.red('No target for input'));
    }
   
    var cmd = s.substring(cp.handle.length + 1);
    cp.process.stdin.write(cmd);
  });

}

function spawnProcess(cp, i) {
  // check to see if the bin exists
  commandExists(cp)
  .then(function() {
    console.log(colorizeMsg(i, cp.handle + ' START'));

    var envars = extend(process.env, cp.spawn.env);
    cp.process = spawn(cp.spawn.command, cp.spawn.args, { env: envars, cwd: cp.spawn.cwd});
    
    [ 'stdout', 'stderr' ].forEach(function( str ) {
      cp.process[ str ].on('data', function( data ) {
        process[ str ].write( 
          data.toString('utf8')
          .replace(/(^|\n)([^\n]+)/g, function( match, group1, group2 ) {
            return colorizeMsg(i, group1 + ( cp.handle + ': ' )) + group2;
          })
        );
      });
    });

    cp.process.on('error', function(err) { 
      console.log(colorizeMsg(i, cp.handle + ": ") + chalk.red('Exited with Error'));
      console.log(err);
    });

    cp.process.on('exit', function(code) { 
      if (code !== 0) { 
        process.stdout.write(
          colorizeMsg(i, cp.handle + ': ') +
          chalk.red('Exited with error code: ' + code + '\n')
        ); 
      } else {
         process.stdout.write(
          colorizeMsg(i, cp.handle + ': FINISH\n')
        );
      } 

      if (completedProcesses.indexOf(cp.handle) < 0) {
        completedProcesses.push(cp.handle);
       
        childProcesses.forEach(function( cp2, i2 ) {
          if (cp2.hasOwnProperty('waitOn') && cp2.waitOn === cp.handle) {
            spawnProcess(cp2, i2);
          }
        });
        if (completedProcesses.length === childProcesses.length) {
          process.exit();
        }
      }
    });
    
  })
  .catch(function(e) {
    console.log(
      colorizeMsg(i, cp.handle + ': ') +
      chalk.red("command %s failed to start"),chalk.bold(cp.spawn.command)
    ); 
    debug(e.stack);
  });
}

function commandExists(cp) {
  return exec('command -v ' + cp.spawn.command + ' >/dev/null 2>&1 || { echo >&2; exit 1; }');
}

function terminateProgram(msg) {
  console.log(chalk.red(msg));
  process.exit(99);
}

function colorizeMsg(i, msg) {
  return chalk[available_colors[i % available_colors.length]](msg);
}
